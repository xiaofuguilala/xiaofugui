
404ms
public TreeNode reConstructBinaryTree(int [] pre,int [] in) { //输入前序命令 ，中序数组命令

        if(pre == null || in ==null){
            return null;
        }

        int rootValue = pre[0];
        TreeNode node =new TreeNode(rootValue); //声明一棵二叉树，
        //当只有一个数的时候
        if(pre.length ==1) {
            node.left = null;
            node.right = null;
            return node;
        }
        //找到中序根的位置
        HashMap<Integer,Integer> map = new HashMap<Integer, Integer>();
        for(int i=0;i<in.length;i++){ //相当于用hashmap遍历了数组
            map.put(in[i],i);
        }
        return prein(pre,0,pre.length-1,in,0,in.length-1,map);//找根节点

    }
     public TreeNode prein(int[] p,int pi,int pj,int[] n, int ni,int nj, HashMap<Integer,Integer> map){
        if(pi > pj){
            return  null;
        }
        TreeNode head=new TreeNode(p[pi]);
        //找到中序的根
        int index=map.get(p[pi]);
        head.left = prein(p,pi+1,pi+index-ni,n,ni,index-1,map);//找左根节点
        head.right = prein(p,pi+index-ni+1,pj,n,index+1,nj,map);
        return head;
    }
